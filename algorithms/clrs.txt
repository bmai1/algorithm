Pseudocode conventions on pg. 20

--------------------------------------------------------------------
Chapter 2 Getting Started
2.1 Insertion sort - see insertion.cpp, insertion.py
Loop invariant is a property of a program loop that is true before/after each iteration
    - e.g. while a[i] < a[j]
Proof of loop invariant correctness:
- initialization
- maintenance
- termination

2.2 Analyzing algorithms - predicting time and memory resources required, RAM model

2.3 Designing algorithms
- recursion, divide and conquer
    - Merge Sort; see Fig 2.3, merge.cpp

2.4 Inversions (41)
Let A[1..n] be an array of n distinct numbers. If i < j and A[i] > A[j], 
then the pair (i, j) is called an inversion of A.
- inversions of [2,3,8,6,1] are (0, 4), (1,4), (2,4), (2,3), (3,4)

--------------------------------------------------------------------
Chapter 3 Growth of Functions 

3.1 Asymptotic notation (43)
- used to describe running time of algorithms
- Θ (theta, both upper/lower bound, average time complexity)
- O (worst, upper bound [least efficient])
    - little o notation = loose upper bound
    - intuitively, lim x->inf f(n) / g(n) = 0;
    
- Ω (omega, lower bound [most efficient]) 
    - ω is to Ω as o is to O 

- see Fig 3.1 time.png
- Function comparison: transitivity, reflexivity, symmetry, trichotomy

3.2 Standard notation, common functions
- monotonicity (leetcode!) -> monotically increasing: m <= n => f(m) <= f(n)
    - strictly increasing is not inclusive
- floor/ceil, modular arithmetic, factorial (n!) > exponential > polynomial > logarithmic growth
- lgn = log2n (binary algorithm), lnn = logen (natural log), lg^kn = (lgn)^k (exponentiaion), lglgn = lg(lgn) (composition)
- fibonacci and the golden ratio φ (phi) -> Binet's Nth-term Formula:
     int fib(int N) {
        double phi = (sqrt(5) + 1) / 2;     
        return round(pow(phi, N) / sqrt(5));
    }

--------------------------------------------------------------------
Chapter 4 - Divide and Conquer

- recurrence relation - equation that defines sequence based on rule
    that gives next term as function of previous terms

4.1 Maximum Subarray Problem (68)

[Best Time to Buy and Sell Stocks]
- brute force = try every pair to buy low, sell high [Ω(n^2)]
- consider daily Δprice as an array
    - now we are trying to find maximum subarray

- any continguous subarray A[i..j] of A[low..high] 
    - in A[low..mid] (low <= i <= j <= mid)
    - in A[mid + 1..high] (mid < i <= j <= high)
    - cross midpoint (low <= i <= mid <= j <= high)
        - A[i..mid] and A[mid + 1..j]




